<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Accelerometer with H-Style Mass Fingers</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #fff;
    }
    canvas {
      display: block;
      background: #fff;
    }
    #info {
      position: absolute;
      top: 0;
      left: 0;
      color: #000;
      padding: 10px;
      font-family: sans-serif;
      font-size: 14px;
    }
    /* Reserve space at the bottom for the Plotly plot */
    #accelerationPlot {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 300px;
      background: #fff;
    }
  </style>
  <!-- Include Plotly library -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="info">
  <p><strong>Accelerometer with H-Style Mass Fingers</strong></p>
  <p>Drag the device frame horizontally. It auto-resets after 5 seconds of inactivity.</p>
  <p>Capacitance: <span id="capacitance">-</span> | Acceleration: <span id="accel">-</span></p>
</div>
<div id="accelerationPlot"></div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const capacitanceDiv = document.getElementById('capacitance');
const accelDiv = document.getElementById('accel');

// Adjust canvas size (reserve space for Plotly plot)
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 300;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Device frame parameters
let deviceX = canvas.width / 2; 
const deviceY = canvas.height / 2;
const frameWidth = 200;
const frameHeight = 200;

// For computing device velocity
let previousDeviceX = deviceX;

// Fixed sensor (frame) parameters â€“ one finger per side
const fixedSensorMargin = 10;
const fixedFingerWidth = 10;
const fixedFingerHeight = 50;

// Proof mass parameters
let massX = deviceX; // horizontal center of the mass
const massY = deviceY;
const massWidth = 80;
const massHeight = 60;
let massVelX = 0;

// Spring damper simulation parameters
const springK = 5;    // spring constant
const damping = 1;    // damping coefficient (N per (m/s))
const massValue = 0.1;
const maxDisplacement = 30;

let dx = 0;
let accel = 0;
let capacitance = 0;
const accel_scaler = 24000;
let printAccel = 0;

let lastInteractionTime = Date.now();
let dragging = false;
let dragOffsetX = 0;

function updateInteractionTime() {
  lastInteractionTime = Date.now();
}

canvas.addEventListener('mousedown', (e) => {
  updateInteractionTime();
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  if (
    mouseX >= deviceX - frameWidth / 2 &&
    mouseX <= deviceX + frameWidth / 2 &&
    mouseY >= deviceY - frameHeight / 2 &&
    mouseY <= deviceY + frameHeight / 2
  ) {
    dragging = true;
    dragOffsetX = mouseX - deviceX;
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (dragging) {
    updateInteractionTime();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    deviceX = mouseX - dragOffsetX;
  }
});

canvas.addEventListener('mouseup', () => {
  dragging = false;
});

canvas.addEventListener('touchstart', (e) => {
  updateInteractionTime();
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const touchX = touch.clientX - rect.left;
  const touchY = touch.clientY - rect.top;
  if (
    touchX >= deviceX - frameWidth / 2 &&
    touchX <= deviceX + frameWidth / 2 &&
    touchY >= deviceY - frameHeight / 2 &&
    touchY <= deviceY + frameHeight / 2
  ) {
    dragging = true;
    dragOffsetX = touchX - deviceX;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (dragging) {
    updateInteractionTime();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    deviceX = touchX - dragOffsetX;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', () => {
  dragging = false;
});

function drawSpring(x1, y1, x2, y2) {
  const segments = 20;
  const amplitude = 10;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  for (let i = 1; i < segments; i++) {
    const t = i / segments;
    const x = x1 + (x2 - x1) * t;
    const y = y1 + amplitude * Math.sin(t * Math.PI * 4);
    ctx.lineTo(x, y);
  }
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

let startTime = Date.now();
let lastFrameTime = Date.now();

// Initialize Plotly acceleration data
var accelerationData = [{
  x: [],
  y: [],
  mode: 'lines',
  type: 'scatter',
  line: { shape: 'spline' }
}];
var accelerationLayout = {
  title: 'Acceleration over Time',
  xaxis: { title: 'Time (s)' },
  yaxis: { title: 'Acceleration' },
  margin: { t: 40, b: 40 }
};
Plotly.newPlot('accelerationPlot', accelerationData, accelerationLayout);

function updatePhysics(dt) {
  // Calculate device velocity (finite difference approximation)
  const deviceVelX = (deviceX - previousDeviceX) / dt;
  previousDeviceX = deviceX;
  
  // Compute relative displacement (dx) between mass and device frame
  dx = massX - deviceX;

    // Clamp dx to a maximum value to avoid excessive forces
    if (Math.abs(dx) > maxDisplacement) {
      dx = Math.sign(dx) * maxDisplacement;
      massX = deviceX + dx;
      massVelX = deviceVelX; // Align mass velocity with device when clamped
    }
  
  // Calculate forces: spring force and damping force based on relative velocity
  const springForce = -springK * dx;
  const dampingForce = -damping * (massVelX - deviceVelX);
  const totalForce = springForce + dampingForce;
  
  // Update acceleration, velocity, and mass position (Euler integration)
  accel = totalForce / massValue;
  massVelX += accel * dt;
  massX += massVelX * dt;
  
  printAccel = accel / accel_scaler * 16;
  
  // Update info display
  capacitance = 200 / (30 + 2 - Math.abs(dx));
  capacitanceDiv.textContent = capacitance.toFixed(2);
  accelDiv.textContent = printAccel.toFixed(2);
  
  const currentTime = (Date.now() - startTime) / 1000;
  Plotly.extendTraces('accelerationPlot', {
    x: [[currentTime]],
    y: [[printAccel]]
  }, [0], 300);
  
  if (!dragging && Date.now() - lastInteractionTime >= 5000) {
    deviceX = canvas.width / 2;
    massX = canvas.width / 2;
    massVelX = 0;
    accelerationData[0].x = [];
    accelerationData[0].y = [];
    Plotly.react('accelerationPlot', accelerationData, accelerationLayout);
    updateInteractionTime();
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const frameLeft = deviceX - frameWidth / 2;
  const frameTop = deviceY - frameHeight / 2;
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 20;
  ctx.strokeRect(frameLeft, frameTop, frameWidth, frameHeight);

  const massTop = massY - massHeight / 2;
  const massLeft = massX - massWidth / 2;

  const fixedFingerX = frameLeft + frameWidth / 2 - fixedFingerWidth / 2;
  ctx.fillStyle = '#666';
  const topFixedY = frameTop + fixedSensorMargin;
  ctx.fillRect(fixedFingerX, topFixedY, fixedFingerWidth, fixedFingerHeight);
  const bottomFixedY = frameTop + frameHeight - fixedSensorMargin - fixedFingerHeight;
  ctx.fillRect(fixedFingerX, bottomFixedY, fixedFingerWidth, fixedFingerHeight);

  const springLeftStartX = frameLeft + fixedSensorMargin;
  const springLeftY = massTop + massHeight / 2; 
  const massLeftEdge = massLeft;  

  const springRightStartX = frameLeft + frameWidth - fixedSensorMargin;
  const springRightY = massTop + massHeight / 2;
  const massRightEdge = massLeft + massWidth;
  
  ctx.strokeStyle = '#aaa';
  ctx.lineWidth = 2;
  drawSpring(springLeftStartX, springLeftY, massLeftEdge, springLeftY);
  drawSpring(springRightStartX, springRightY, massRightEdge, springRightY);

  ctx.fillStyle = '#aaa';
  ctx.fillRect(massLeft, massTop, massWidth, massHeight);

  const massFingerWidth = 10;
  const massFingerHeight = 50;
  const leftFingerX = massLeft;
  const fingerTopY = massTop - massFingerHeight;
  const fingerBottomY = massTop + massHeight;
  ctx.fillRect(leftFingerX, fingerTopY, massFingerWidth, massFingerHeight);
  ctx.fillRect(leftFingerX, fingerBottomY, massFingerWidth, massFingerHeight);
  
  const rightFingerX = massLeft + massWidth - massFingerWidth;
  ctx.fillRect(rightFingerX, fingerTopY, massFingerWidth, massFingerHeight);
  ctx.fillRect(rightFingerX, fingerBottomY, massFingerWidth, massFingerHeight);
}

function animate() {
  const now = Date.now();
  const dt = (now - lastFrameTime) / 1000;
  lastFrameTime = now;
  updatePhysics(dt);
  render();
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
